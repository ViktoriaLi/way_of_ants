сделать ограничение на дефис в комнате +
вершины не должны иметь одинаковое название
добавить проверку, чтоб была комната после старта и енда +

перед муравьями могут быть только коменты +
если нет ни одного пути - эрор
не может быть 2 старта или энда +
после старт и энд не может быть никаких символов +
могут быть отрицательные коорд +
коорд не могут быть символами +
муравьев не может быть 0  меньше +
если хватает данных для прохождения, то алгоритм должен отработать, а не выводить эрор
комнаты могут быть в любом порядке
если нет входа в энд это эррор
если начались связи, а между ними есть комната, то эррор

нужно ли считывать с каких то фд кроме 0?
если в связи 2 одинаковых имени?
сделать запрет дубликата имени комнаты
при некорректном вводе во времяи связкй останавливать считывание и начинать искать пути

на маленькой карте сегментейшн фолт
проеврить правильность выхода, если нет пути ни одного
lemin_reading лемин ридинг - пропускает ли некорректные строки внизу цикла?

могут ли быть пробелы в комментах
может все экситы заменить на брейки и вывести эррор только если не будет хватать данных3?

сделать защиту если связи дублируются, чтоб дважды не вписывать одинаковые

можно посчитать сколькл связей в конечной комнате и не искать доп пути больше чем ссвязей
сделать функцию которая проверить список связей на повторы и на соответствие названию комнат

заранее проверить, есть ли связи у финишной комнате, есди нет, эррор
поправить распределенение муравьев по комнатам, для комнаты, равной по длине количеству шагов, не должно быть больше 1 муравья

сделать выход если не удается найти путь в цикли для больше 1 пути

на маке не вывожит последнее имя комнаты

появился сегфолт на тесте2
сделать защиту если пришла ссылка вида 0-0, 1-1
если повторная связь - игнорить или эррорить?
проверить, чтоб комнаты по имени тоде не совпадали с уже существующими
что если координаты разных комнат совпадают?



void create_path(t_ways **all_paths, t_room_list *queue, int way_number)
{
	t_way *new;
	t_way *new_head;
	t_room_list *tmp_queue;
	int count;
	t_ways *tmp;

	count = 1;
	new = NULL;
	new_head = NULL;
	tmp_queue = queue;
	if (!(tmp = (t_ways *)malloc(sizeof(t_ways *))))
		return ;
	if (!(tmp->way = (t_way *)malloc(sizeof(t_way))))
		return ;
  ft_printf("way_number %d\n", way_number);
	tmp->number = way_number;
	tmp->ant = 0;
	tmp->next = *all_paths;
	while (tmp_queue->next)
		tmp_queue = tmp_queue->next;
	while (tmp_queue->room->which_room >= 0)
	{

		tmp->way->name = tmp_queue->room->name;
		ft_printf("tmp_queue->room->name %s\n", tmp->way->name);
		tmp->way->if_empty = 1;
		tmp->way->distance = count;
		count++;
		tmp->way->next = new_head;
		new_head = tmp->way;
		tmp_queue->room->usage = 3;
		if (tmp_queue->room->which_room == START_ROOM)
			break;
		tmp_queue->room = tmp_queue->room->enter;
		if (!(tmp->way = (t_way *)malloc(sizeof(t_way))))
			return ;
	}
	tmp->next = *all_paths;
	*all_paths = tmp;
	new = tmp->way;
	while (new)
	{
		ft_printf("3path%s\n", new->name);
		new = new->next;
	}
}
