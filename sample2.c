#include <iostream>
typedef unsigned int WORD ;

using namespace std ;

const MaxN = 101 ;

struct List {
   List (){} ;
   List ( int _V , List * _next ) { V = _V ; next =  _next ;}
   List * next  ;
   int V ;
};

int    e[MaxN];            // Избыток
int    h[MaxN];            // Высота вершины
int    f[MaxN][MaxN];         // Текущее значение предпотока
int    c[MaxN][MaxN];         // Пропускные способности ребер

//List L ;               // все вернины V[G]\{s,t}
//List N[MaxN] ;            // список связности
List *head[MaxN] , *current[MaxN] , *headL , *pre;

int  n , m , s = 1,  t , minH ;      // s -  исток , t- сток

//----------------------------------------------------------------------------------------------
 void ConstructL(){            // В списке L  хранятся все вершины кроме s,t
               // т.е V[G]\{s,t}
      List *cur  ;
      List * t = new List (2 , NULL );
      pre = headL = t ; cur = t ;
      for (int i = 3 ; i < n ; i++ )
      {
         List *t  = new List ( i , NULL) ;
         cur->next = t ;
         cur = cur->next ;
      }
 }
//----------------------------------------------------------------------------------------------
 int min (int a , int b ){
    return a<b ? a:b ;
 }
//----------------------------------------------------------------------------------------------                                       // перемещаем вершину в начало
 void MoveToFront ( List *u ) {

   if ( pre == u )return ;

   pre->next = u->next ;

   List * t = new List (u->V , headL ) ;
   pre = headL = t ;

   delete u ;
 }
//----------------------------------------------------------------------------------------------
               // Инициализируем предпоток
 void Initilize_PreFlow () {
               // здесь ндеюсь всё понятно
    h[s] = n ;
    for (int u = 1 ; u <= n ; u++ ){
       if ( c[s][u] > 0 ){
          f[s][u] =  c[s][u] ;
          f[u][s] = -c[s][u] ;
          e[u] = c[s][u];
       }
    }
 }
//----------------------------------------------------------------------------------------------
               // Проталкиваем поток т.е в вершине u есть избыток
 void Push (int u , int v ){         // и нам надо протолкнуть поток дальше

    int d = min (e[u] , c[u][v]-f[u][v]);


    f[u][v] =  f[u][v] + d ;        // увеличиваем поток по ребру (u,v)
    f[v][u] = -f[u][v] ;

    e[u] = e[u] - d ;
    e[v] = e[v] + d ;
 }
 //----------------------------------------------------------------------------------------------
                 //  поднимаем вершину чтоб протолкнут поток
 void Lift ( int u ) {              //  т.к проталкивать можно только из вешин большей высоты
    minH = 100000 ;
   List *v = head[u];           //просматриваем все вершины в остаточной сети и поднимаем даную
   while (v){              // так чтоб она стала на 1 выше самой низкой
      if (minH > h[v->V] && c[u][v->V]-f[u][v->V] > 0 )minH = h[v->V];
      v =  v->next ;
   }
   h[u] = ( minH +1 ) ;
 }
//----------------------------------------------------------------------------------------------
 void Discharge ( int u ){         // разгрузка вершины
    while ( e[u] > 0 ){         // нока есть избыток
       List* v = current[u];
       if ( current[u] == NULL ){
          Lift ( u );            // поднимаем вершину
          current[u] = head[u];
       }
       else if ( c[u][v->V]-f[u][v->V] > 0 && h[u] == h[v->V] + 1)
          Push (u , v->V );      // нашли допустимое ребро и протолкнули поток
       else current[u] = current[u]->next ;   // переходим к следующему элементу
    }
 }
//----------------------------------------------------------------------------------------------
 void Lift_To_Front (){

   Initilize_PreFlow() ;          // Формируем начальные предпоток
   ConstructL() ;

   for (int i = 2 ; i < n ; i++ )       // s == 1 , t == n
      current[i] = head[i];

   List *u = headL ;

   while ( u != NULL ){
      int old_height  = h[u->V];

      Discharge( u->V );       // Разгружаем вершину u

      if ( h[u->V] > old_height ){    // если вершина было поднята то
         MoveToFront ( u );   // перемещаем её в начало списка
         u = headL;
      }
      pre = u ;
      u = u->next ;       // переходим к следующей вершине
   }
   // при выходе из процедуры все объекты созданые оператор new надо
   // удалить за не надобностью , мне влом оставляю это вам :)
 }
//------------------------------------------------------------------------------------------------
 int main () {

   cin >> n >> m ;         // здесь n - количество вершин m - количество рёбер
   int a , b , cf ;         // ..пропускная способность ребра (a,b) == cf
   for (int i = 0 ; i < m ; i++ )
   {
       cin >> a >> b >> cf ;
       c[a][b] = cf;
   }
               //.. для каждой вершины u Є V строим одностороний список
    for (int i = 1 ; i <= n ; i++ ){        // соседеё вершина v находится в этом списке ели
       List *cur ;      // (u,v) Є E лил (v,u) Є E
       int w = 0 ;
       for (int j = 1 ; j <= n ; j ++ ){
          if ( c[i][j] > 0 || c[j][i] > 0 ){
            List * t = new List( j , NULL ) ;
            if (!w){
               head[i] = t ;
               cur = t ;
               w = 1 ;
            }
            else {
               cur->next = t ;
               cur = cur->next ;
            }
          }
       }
    }

Lift_To_Front ();
               // в масиве f имеем поток
int sum = 0 ;
for (int i = 1 ; i <= n ; i++ )
   sum +=  f[i][n];

   cout << sum ;
    return 0 ;
 }